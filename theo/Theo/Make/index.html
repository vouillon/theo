<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (theo.Theo.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">theo</a> &#x00BB; <a href="../index.html">Theo</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Theo.Make</span></code></h1><p>Functor to create a BDD implementation for a specific theory.</p><p><code>Make(T)</code> produces a module containing all BDD operations (logical connectives, quantifiers, etc.) specialized for the theory <code>T</code>.</p><ul><li>Use <code>Make(Void)</code> for standard boolean BDDs.</li><li>Use <code>Make(Combine(A)(B))</code> for multi-theory BDDs.</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li><li><a href="#types">Types</a></li><li><a href="#standard-interface">Standard Interface</a></li><li><a href="#atomic-boolean-formulas">Atomic Boolean Formulas</a></li><li><a href="#logical-constants">Logical Constants</a></li><li><a href="#logical-connectives">Logical Connectives</a></li><li><a href="#properties">Properties</a></li><li><a href="#constraints">Constraints</a></li><li><a href="#operations">Operations</a></li><li><a href="#quantifiers">Quantifiers</a></li><li><a href="#solving">Solving</a></li><li><a href="#batch-operations">Batch Operations</a></li><li><a href="#debugging">Debugging</a></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-T"><a href="#argument-1-T" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-T/index.html">T</a></span><span> : <a href="../module-type-Theory/index.html">Theory</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><h2 id="types"><a href="#types" class="anchor"></a>Types</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Abstract type representing a BDD expression.</p></div></div><h2 id="standard-interface"><a href="#standard-interface" class="anchor"></a>Standard Interface</h2><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> checks if <code>a</code> and <code>b</code> are physically equal. Since hash-consing guarantees unique representation, this is equivalent to logical equality. Same as <code>equivalent</code>.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare a b</code> compares the unique identifiers of <code>a</code> and <code>b</code>. defines a total ordering suitable for <code>Set</code> and <code>Map</code>.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash a</code> returns the unique identifier of <code>a</code>. Suitable for <code>Hashtbl</code>.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>size expr</code> returns the number of unique nodes in the BDD. Useful for analyzing BDD complexity.</p><p>Complexity: O(|expr|)</p></div></div><h2 id="atomic-boolean-formulas"><a href="#atomic-boolean-formulas" class="anchor"></a>Atomic Boolean Formulas</h2><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span><span><span class="type-var">'kind</span> <a href="../Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>bool v</code> creates an expression that is true when boolean variable <code>v</code> is true.</p></div></div><h2 id="logical-constants"><a href="#logical-constants" class="anchor"></a>Logical Constants</h2><div class="odoc-spec"><div class="spec value anchored" id="val-true_"><a href="#val-true_" class="anchor"></a><code><span><span class="keyword">val</span> true_ : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The constant true expression.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-false_"><a href="#val-false_" class="anchor"></a><code><span><span class="keyword">val</span> false_ : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The constant false expression.</p></div></div><h2 id="logical-connectives"><a href="#logical-connectives" class="anchor"></a>Logical Connectives</h2><div class="odoc-spec"><div class="spec value anchored" id="val-not"><a href="#val-not" class="anchor"></a><code><span><span class="keyword">val</span> not : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>not expr</code> negates the expression.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and_"><a href="#val-and_" class="anchor"></a><code><span><span class="keyword">val</span> and_ : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>and_ a b</code> computes the conjunction (AND) of two expressions.</p><p>Complexity: O(|a| × |b|) where |·| is the number of nodes</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-or_"><a href="#val-or_" class="anchor"></a><code><span><span class="keyword">val</span> or_ : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>or_ a b</code> computes the disjunction (OR) of two expressions.</p><p>Complexity: O(|a| × |b|)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xor"><a href="#val-xor" class="anchor"></a><code><span><span class="keyword">val</span> xor : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xor a b</code> computes the exclusive or of two expressions. True when exactly one of <code>a</code> or <code>b</code> is true.</p><p>Complexity: O(|a| × |b|)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iff"><a href="#val-iff" class="anchor"></a><code><span><span class="keyword">val</span> iff : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>iff a b</code> computes the biconditional (if and only if) of two expressions. True when <code>a</code> and <code>b</code> have the same truth value. Equivalent to <code>not (xor a b)</code>.</p><p>Complexity: O(|a| × |b|)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-implies"><a href="#val-implies" class="anchor"></a><code><span><span class="keyword">val</span> implies : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>implies a b</code> constructs the implication <code>a =&gt; b</code> (equivalent to <code>not a || b</code>). Returns a BDD representing the logical implication.</p><p>To check if <code>a</code> logically implies <code>b</code> (i.e., is a tautology), use <code>is_tautology (implies a b)</code>.</p><p>Complexity: O(|a| × |b|)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ite"><a href="#val-ite" class="anchor"></a><code><span><span class="keyword">val</span> ite : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ite cond then_ else_</code> computes the If-Then-Else operation. Equivalent to <code>(cond &amp;&amp; then_) || (not cond &amp;&amp; else_)</code>.</p><p>Complexity: O(|cond| × |then_| × |else_|)</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Syntax for convenient infix operators. Open locally with <code>let open Theo.Syntax in ...</code></p></div></div><h2 id="properties"><a href="#properties" class="anchor"></a>Properties</h2><div class="odoc-spec"><div class="spec value anchored" id="val-is_tautology"><a href="#val-is_tautology" class="anchor"></a><code><span><span class="keyword">val</span> is_tautology : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_tautology expr</code> returns true if <code>expr</code> is the constant true.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_satisfiable"><a href="#val-is_satisfiable" class="anchor"></a><code><span><span class="keyword">val</span> is_satisfiable : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_satisfiable expr</code> returns true if <code>expr</code> has at least one satisfying assignment. Equivalent to <code>sat expr &lt;&gt; None</code> but more efficient.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equivalent"><a href="#val-equivalent" class="anchor"></a><code><span><span class="keyword">val</span> equivalent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equivalent a b</code> checks if <code>a</code> and <code>b</code> are structurally identical. Due to hash-consing, structurally identical BDDs represent the same logical function.</p><p>Complexity: O(1)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logical_implies"><a href="#val-logical_implies" class="anchor"></a><code><span><span class="keyword">val</span> logical_implies : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>logical_implies a b</code> checks if <code>a</code> logically implies <code>b</code> (i.e., <code>a =&gt; b</code> is valid/tautology) without fully constructing the result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_disjoint"><a href="#val-is_disjoint" class="anchor"></a><code><span><span class="keyword">val</span> is_disjoint : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_disjoint a b</code> checks if <code>a</code> and <code>b</code> are disjoint (i.e., <code>a /\ b</code> is unsatisfiable) without fully constructing the result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_exhaustive"><a href="#val-is_exhaustive" class="anchor"></a><code><span><span class="keyword">val</span> is_exhaustive : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_exhaustive a b</code> checks if <code>a</code> and <code>b</code> cover the entire space (i.e., <code>a \/ b</code> is a tautology) without fully constructing the result.</p></div></div><h2 id="constraints"><a href="#constraints" class="anchor"></a>Constraints</h2><div class="odoc-spec"><div class="spec type anchored" id="type-atomic_constraint"><a href="#type-atomic_constraint" class="anchor"></a><code><span><span class="keyword">type</span> atomic_constraint</span></code></div><div class="spec-doc"><p>Represents an atomic constraint on a variable that contributes to satisfying the formula.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-constraint_view"><a href="#type-constraint_view" class="anchor"></a><code><span><span class="keyword">type</span> constraint_view</span><span> = </span></code><ol><li id="type-constraint_view.Constraint" class="def variant constructor anchored"><a href="#type-constraint_view.Constraint" class="anchor"></a><code><span>| </span><span><span class="constructor">Constraint</span> : </span><span>{</span></code><ol><li id="type-constraint_view.var" class="def record field anchored"><a href="#type-constraint_view.var" class="anchor"></a><code><span>var : <span><span class="type-var">'kind</span> <a href="../Var/index.html#type-t">Var.t</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The variable involved in the constraint.</p><span class="comment-delim">*)</span></div></li><li id="type-constraint_view.payload" class="def record field anchored"><a href="#type-constraint_view.payload" class="anchor"></a><code><span>payload : <span><span class="type-var">'kind</span> <a href="#type-payload">payload</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The nature of the constraint: <code>Bool</code> for boolean variables, or <code>Theory desc</code> for theory atoms.</p><span class="comment-delim">*)</span></div></li><li id="type-constraint_view.value" class="def record field anchored"><a href="#type-constraint_view.value" class="anchor"></a><code><span>value : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The truth value asserted for this constraint.</p><ul><li>If <code>value</code> is <code>true</code>, the constraint is <code>var</code> (or <code>atom</code>).</li><li>If <code>value</code> is <code>false</code>, the constraint is <code>not var</code> (or <code>not atom</code>).</li></ul><span class="comment-delim">*)</span></div></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <a href="#type-constraint_view">constraint_view</a></span></code></li></ol></div><div class="spec-doc"><p>Pattern-matchable view of the atomic constraint</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-payload"><a href="#type-payload" class="anchor"></a><code><span><span class="keyword">and</span> <span>'kind payload</span></span><span> = </span></code><ol><li id="type-payload.Bool" class="def variant constructor anchored"><a href="#type-payload.Bool" class="anchor"></a><code><span>| </span><span><span class="constructor">Bool</span> : <span>bool <a href="#type-payload">payload</a></span></span></code></li><li id="type-payload.Theory" class="def variant constructor anchored"><a href="#type-payload.Theory" class="anchor"></a><code><span>| </span><span><span class="constructor">Theory</span> : <span><span class="type-var">'kind</span> <a href="#type-desc">desc</a></span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'kind</span> <a href="#type-payload">payload</a></span></span></code></li></ol></div><div class="spec-doc"><p>The payload of an atomic constraint.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-desc"><a href="#type-desc" class="anchor"></a><code><span><span class="keyword">and</span> <span>'kind desc</span></span><span> = <span><span class="type-var">'kind</span> <a href="argument-1-T/index.html#type-t">T.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-view_constraint"><a href="#val-view_constraint" class="anchor"></a><code><span><span class="keyword">val</span> view_constraint : <span><a href="#type-atomic_constraint">atomic_constraint</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constraint_view">constraint_view</a></span></code></div><div class="spec-doc"><p><code>view_constraint c</code> returns a pattern-matchable view of the atomic constraint <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Constraint"><a href="#module-Constraint" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Constraint/index.html">Constraint</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="operations"><a href="#operations" class="anchor"></a>Operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-restrict"><a href="#val-restrict" class="anchor"></a><code><span><span class="keyword">val</span> restrict : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-atomic_constraint">atomic_constraint</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>restrict expr constraints</code> simplifies <code>expr</code> by assuming the specified constraints hold.</p><p>Complexity: O(|expr|)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-constant_result"><a href="#type-constant_result" class="anchor"></a><code><span><span class="keyword">type</span> constant_result</span><span> = </span></code><ol><li id="type-constant_result.Constant" class="def variant constructor anchored"><a href="#type-constant_result.Constant" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant</span> <span class="keyword">of</span> bool</span></code></li><li id="type-constant_result.NonConstant" class="def variant constructor anchored"><a href="#type-constant_result.NonConstant" class="anchor"></a><code><span>| </span><span><span class="constructor">NonConstant</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ite_constant"><a href="#val-ite_constant" class="anchor"></a><code><span><span class="keyword">val</span> ite_constant : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constant_result">constant_result</a></span></code></div><div class="spec-doc"><p><code>ite_constant f g h</code> evaluates if the result of <code>ite f g h</code> is a constant boolean without fully constructing the BDD. Returns <code>Constant b</code> if the result corresponds to <code>b</code>, or <code>NonConstant</code> otherwise.</p></div></div><h2 id="quantifiers"><a href="#quantifiers" class="anchor"></a>Quantifiers</h2><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span><span class="type-var">_</span> <a href="../Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>exists v expr</code> eliminates variable <code>v</code> from <code>expr</code> by computing the disjunction over all possible values. For a boolean variable, this is equivalent to <code>restrict expr [Boolean(v, true)] || restrict expr [Boolean(v, false)]</code>. For theory variables, it quantifies over all atoms mentioning <code>v</code>.</p><p>Example: <code>let expr' = exists b (and_ (atom b) (atom c)) (* Result: atom c *)</code></p><p>Complexity: O(|expr|²)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forall"><a href="#val-forall" class="anchor"></a><code><span><span class="keyword">val</span> forall : <span><span><span class="type-var">_</span> <a href="../Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>forall v expr</code> eliminates variable <code>v</code> from <code>expr</code> by computing the conjunction over all possible values. For a boolean variable, this is equivalent to <code>restrict expr [Boolean(v, true)] &amp;&amp; restrict expr [Boolean(v, false)]</code>.</p><p>Example: <code>let expr' = forall b (or_ (atom b) (atom c)) (* Result: atom c *)</code></p><p>Complexity: O(|expr|²)</p></div></div><h2 id="solving"><a href="#solving" class="anchor"></a>Solving</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sat"><a href="#val-sat" class="anchor"></a><code><span><span class="keyword">val</span> sat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-atomic_constraint">atomic_constraint</a> list</span> option</span></span></code></div><div class="spec-doc"><p><code>sat expr</code> finds a satisfying set of constraints for <code>expr</code>, if one exists. Returns <code>Some constraints</code> where <code>constraints</code> is a list of atomic constraints that make the expression true. Returns <code>None</code> if the expression is unsatisfiable (equivalent to <code>false_</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shortest_sat"><a href="#val-shortest_sat" class="anchor"></a><code><span><span class="keyword">val</span> shortest_sat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-atomic_constraint">atomic_constraint</a> list</span> option</span></span></code></div><div class="spec-doc"><p><code>shortest_sat expr</code> finds a satisfying set of constraints with the minimum number of atomic constraints (shortest path in the BDD DAG). Returns <code>None</code> if unsatisfiable.</p></div></div><h2 id="batch-operations"><a href="#batch-operations" class="anchor"></a>Batch Operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-and_list"><a href="#val-and_list" class="anchor"></a><code><span><span class="keyword">val</span> and_list : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>and_list exprs</code> computes the conjunction of all expressions in <code>exprs</code>. Returns <code>true_</code> for an empty list. Uses a divide-and-conquer strategy to minimize intermediate BDD sizes and maximize cache reuse.</p><p>Example: <code>let expr = and_list [e1; e2; e3]</code></p><p>Complexity: In the worst case, combining N BDDs of size S can result in exponential growth O(S^N). However, for many practical constraint problems, the divide-and-conquer approach yields typically O(S log N) performance.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-or_list"><a href="#val-or_list" class="anchor"></a><code><span><span class="keyword">val</span> or_list : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>or_list exprs</code> computes the disjunction of all expressions in <code>exprs</code>. Returns <code>false_</code> for an empty list.</p><p>Example: <code>let expr = or_list [e1; e2; e3]</code></p><p>Complexity: Worst case O(S^N), typically O(S log N).</p></div></div><h2 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string expr</code> returns a human-readable representation of the BDD structure. Shows the decision tree with atoms and branches.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_dot"><a href="#val-print_dot" class="anchor"></a><code><span><span class="keyword">val</span> print_dot : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print_dot chan expr</code> prints the BDD in Graphviz DOT format to the given channel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stats"><a href="#val-print_stats" class="anchor"></a><code><span><span class="keyword">val</span> print_stats : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print_stats ()</code> prints statistics for all internal caches (atom table, node table, operation caches) to stdout. Useful for debugging and performance analysis.</p></div></div></div></body></html>
